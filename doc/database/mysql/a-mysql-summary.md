# A MySQL Summary

自己对使用MySQL过程中记录的内容进行整理

[MySQL优化，集群，存储过程](https://www.aliyun.com/jiaocheng/1109737.html)

## mysql自增主键和uuidz作为主键比较

在500W记录表的测试下：

1. 普通单条或者20条左右的记录检索，uuid为主键的相差不大几乎效率相同；
2. 但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；
3. 在范围查询做统计汇总的时候，自增id的效率要大于uuid；
4. 在存储上面，自增id所占的存储空间是uuid的1/2；

mysql 自增id和UUID做主键性能分析，及最优方案

1. 为什么要使用uuid做主键

(1).其实在innodb存储引擎下，自增长的id做主键性能已经达到了最佳。不论是存储和读取速度都是最快的，而且占的存储空间也是最小。

(2).但是在我们实际到项目中会碰到问题，历史数据表的主键id会与数据表的id重复，两张自增id做主键的表合并时，id一定会有冲突，但如果各自的id还关联了其他表，这就很不好操作。

(3).如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。

2. UUID优缺点

缺点：

- 影响插入速度， 并且造成硬盘使用率低
- uuid之间比较大小相对数字慢不少， 影响查询速度。
- uuid占空间大， 如果你建的索引越多， 影响越严重

优点：

出现数据拆分、合并存储的时候，能达到全局的唯一性

3. 最优方案

(1).InnoDB引擎表是基于B+树的索引组织表。

(2).B+树：B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。

(3).InnoDB主索引：叶节点包含了完整的数据记录。这种索引叫做聚集索引。InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引

(4).聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

综合上述可得：

(1).如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。为了存储和查询性能应该使用自增长id做主键。

(2).对于InnoDB的主索引，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力，此时不适合使用UUID做物理主键，可以把它作为逻辑主键，物理主键依然使用自增ID。为了全局的唯一性，应该用uuid做索引关联其他表或做外键。

4.如果非要使用uuid做主键，下面是小建议：

如果是主从即M-S模式，最好是不使用mysql自带函数uuid来生成唯一主键，因为主表生成的uuid要再关联从表时，需要再去数据库查出这个uuid，需要多进行一次数据库交互，而且在这个时间差里面主表很有可能还有数据生成，这样就很容易导致关联的uuid出错。如果真要使用uuid，可以在Java中生成后，直接存储到DB里，这时主从的uuid就是一样的了！

总结

（1）单实例或者单节点组：

经过500W、1000W的单机表测试，自增ID相对UUID来说，自增ID主键性能高于UUID，磁盘存储费用比UUID节省一半的钱。所以在单实例上或者单节点组上，使用自增ID作为首选主键。

（2）分布式架构场景：

20个节点组下的小型规模的分布式场景，为了快速实现部署，可以采用多花存储费用、牺牲部分性能而使用UUID主键快速部署；

20到200个节点组的中等规模的分布式场景，可以采用自增ID+步长的较快速方案。

200以上节点组的大数据下的分布式场景，可以借鉴类似twitter雪花算法构造的全局自增ID作为主键。

参考：

[MySQL 使用自增ID主键和UUID 作为主键的优劣比较详细过程（从百万到千万表记录测试）](https://www.cnblogs.com/barrywxx/p/7723122.html)

6.1、自增ID主键+步长，适合中等规模的分布式场景

6.2、UUID，适合小规模的分布式环境

对于InnoDB这种聚集主键类型的引擎来说，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力，而且由于索引和数据存储在一起，字符串做主键会造成存储空间增大一倍。

在存储和检索的时候，innodb会对主键进行物理排序，这对auto_increment_int是个好消息，因为后一次插入的主键位置总是在最后。但是对uuid来说，这却是个坏消息，因为uuid是杂乱无章的，每次插入的主键位置是不确定的，可能在开头，也可能在中间，在进行主键物理排序的时候，势必会造成大量的 IO操作影响效率，在数据量不停增长的时候，特别是数据量上了千万记录的时候，读写性能下降的非常厉害。

优点：搭建比较简单，不需要为主键唯一性的处理。

缺点：占用两倍的存储空间（在云上光存储一块就要多花2倍的钱），后期读写性能下降厉害。

6.3、雪花算法自造全局自增ID，适合大数据环境的分布式场景

[mysql 自增id和UUID做主键性能分析，及最优方案](https://blog.csdn.net/xdsxhdyy/article/details/78994045)

[MySQL 使用自增ID主键和UUID 作为主键的优劣比较详细过程（500W单表）](https://blog.csdn.net/mchdba/article/details/52279523)

[MySQL 使用自增ID（int）主键和UUID（varchar）作为主键的优劣比较](https://blog.csdn.net/HeatDeath/article/details/79833462)

## mysql双主复制中，会有什么缺点，例如主键冲突？

两个数据库做主主，会不会遇上主键冲突的问题，会的话要怎么解决。目前要做主主的库有100多张表。

[mysql双主复制中，会有什么缺点，例如主键冲突？ - 河南-老宋(志强)的回答 - 知乎](https://www.zhihu.com/question/273995784/answer/373472763)

>如果你只是简单的用，建议你还是不要双写。\
\
如果你真的想用，那建议从表级的分开，比如某个节点只操作某个表的东西。

[mysql双主复制中，会有什么缺点，例如主键冲突？ - 黄承开的回答 - 知乎](https://www.zhihu.com/question/273995784/answer/372490790)

>多主多写的话，会。\
1.多主单写。性能冗余。\
2.主键生成策略针对主数量取模。简单可靠，无法扩展。\
3.由应用生成主键。需要改造业务代码。\
4.database mesh。这个就需要架构的改造了。
